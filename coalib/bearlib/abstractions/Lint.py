from contextlib import contextmanager
import re
import shutil

from coalib.bears.LocalBear import LocalBear
from coalib.misc.Decorators import enforce_signature
from coalib.misc.Shell import run_shell_command
from coalib.results.Diff import Diff
from coalib.results.Result import Result
from coalib.results.RESULT_SEVERITY import RESULT_SEVERITY


# TODO Move to another file?
class LinterHandler:
    # TODO Damn fuck what about required section settings....
    # TODO --> Maybe it's possible to insert metadata after instantation?
    # TODO --> should be possible, bear has such a function...
    # TODO ------> But how should setting-names, types and default values look?
    # TODO Doing the handler stuff below static? see line above^^
    def create_arguments(self, filename, file, config_file):
        raise NotImplementedError

    def generate_config(self, filename, file):
        return None

    @classmethod
    def check_prerequisites(cls):
        if shutil.which(cls.executable) is None:
            return repr(cls.executable) + " is not installed."
        else:
            return True


#TODO Replace `x` with ``x`` because of rst

# TODO docs

@enforce_signature
def Linter(executable: str,
           provides_correction: bool=False,
           use_stdin: bool=False,
           use_stderr: bool=False,
           **kwargs):
    # TODO Document on ValueError for non-LinterHandler-derivative
    """
    Decorator that creates a ``LocalBear`` that is able to process results from
    an external linter tool.

    The interface to the tool is the ``LinterHandler`` class that defines
    functions you can hook up to. See ``LinterHandler`` for more details on
    usage.

    Using this decorator requires your class derives from ``LinterHandler``.

    >>> @Linter("xlint")
    ... class XLintBear(LinterHandler):
    ...     def create_arguments(self, filename, file, config_file):
    ...         return ("--lint", filename)
    >>> try:
    ...     @Linter("zlint")
    ...     class ZLintBear:
    ...         def create_arguments(self, filename, file, config_file):
    ...             return [filename]
    ... catch ValueError:
    ...     print("ZLintBear is no LinterHandler!")
    ZLintBear is no LinterHandler!

    :param executable:          The linter tool.
    :param provides_correction: Whether the underlying executable provides as
                                output the entirely corrected file instead of
                                issue messages.
    :param use_stdin:           Whether the input file is send via stdin
                                instead of passing it over the
                                command-line-interface.
    :param use_stderr:          Whether stderr instead of stdout should be
                                grabbed for the executable output.
    :param output_regex:        The regex expression as a string that is used
                                to parse the output generated by the underlying
                                executable. It should use as many of the
                                following named groups (via `(?P<name>...)`) to
                                provide a good result:

                                - line - The line where the issue starts.
                                - column - The column where the issue starts.
                                - end_line - The line where the issue ends.
                                - end_column - The column where the issue ends.
                                - severity - The severity of the issue.
                                - message - The message of the result.
                                - origin - The origin of the issue.

                                Needs to be provided if `provides_correction`
                                is `False`.
    :param severity_map:        A dict used to map a severity string (captured
                                from the `output_regex` with the named group
                                `severity`) to an actual
                                `coalib.results.RESULT_SEVERITY` for a result.
                                By default maps the values `error` to
                                `RESULT_SEVERITY.MAJOR`, `warning` to
                                `RESULT_SEVERITY.NORMAL` and `info` to
                                `RESULT_SEVERITY.INFO`.
                                Only needed if `provides_correction` is
                                `False`.
    :param diff_severity:       The severity to use for all results if
                                `provides_correction` is set. By default this
                                value is
                                `coalib.results.RESULT_SEVERITY.NORMAL`.
    :param diff_message:        The message to use for all results if
                                `provides_correction` is set. By default this
                                value is `"Inconsistency found."`.
    :return:                    A `LocalBear` derivation that lints code using
                                an external tool.
    """
    kwargs["executable"] = executable
    kwargs["use_stdin"] = use_stdin
    kwargs["use_stderr"] = use_stderr
    kwargs["provides_correction"] = provides_correction

    if kwargs["provides_correction"]:
        if "diff_severity" not in kwargs:
            kwargs["diff_severity"] = RESULT_SEVERITY.NORMAL
        if "diff_message" not in kwargs:
            kwargs["diff_message"] = "Inconsistency found."
    else:
        if "output_regex" not in kwargs:
            raise ValueError("No `output_regex` specified.`")

        kwargs["output_regex"] = re.compile(kwargs["output_regex"])

        # Don't setup severity_map if one is provided by user or if it's not
        # used inside the output_regex.
        if (
                "severity" in kwargs["output_regex"].groupindex and
                "severity_map" not in kwargs):
            kwargs["severity_map"] = {"error": RESULT_SEVERITY.MAJOR,
                                      "warning": RESULT_SEVERITY.NORMAL,
                                      "info": RESULT_SEVERITY.INFO}

    def create_linter(cls):
        if not isinstance(cls, LinterHandler):
            raise ValueError("Provided class must be derived from "
                             "`LinterHandler`.")

        class Linter(LocalBear):
            @property
            def handler(self):
                return cls

            #def __repr__(self):
            #    return repr(self.handler)

            check_prerequisites = handler.check_prerequisites

            def _execute_command(self, args, stdin=None):
                return run_shell_command((kwargs["executable"],) + tuple(args),
                                         stdin=stdin)

            def match_to_result(self, match, filename):
                """
                Converts a regex match's groups into a result.

                :param match:    The match got from regex parsing.
                :param filename: The name of the file from which this match is got.
                """
                groups = self._get_groupdict(match)

                # Pre process the groups
                for variable in ("line", "column", "end_line", "end_column"):
                    if variable in groups and groups[variable]:
                        groups[variable] = int(groups[variable])

                if "origin" in groups:
                    groups['origin'] = "{} ({})".format(str(type(self).__name__),
                                                        str(groups["origin"]))

                return Result.from_values(
                    origin=groups.get("origin", self),
                    message=groups.get("message", ""),
                    file=filename,
                    severity=int(groups.get("severity", RESULT_SEVERITY.NORMAL)),
                    line=groups.get("line", None),
                    column=groups.get("column", None),
                    end_line=groups.get("end_line", None),
                    end_column=groups.get("end_column", None))

            if kwargs["provides_correction"]:
                def _process_output(self, output, filename, file):
                    for diff in Diff.from_string_arrays(
                            file,
                            output.splitlines(keepends=True)).split_diff():
                        yield Result(self,
                                     self.diff_message,
                                     affected_code=(diff.range(filename),),
                                     diffs={filename: diff},
                                     severity=self.diff_severity)
            else:
                def _process_output(self, output, filename, file):
                    for match in self.output_regex.finditer(output):
                        # TODO Inline match_to_result? I'm really not sure,
                        # TODO this function makes sense...
                        yield self.match_to_result(match, filename)

            if kwargs["use_stderr"]:
                @staticmethod
                def _grab_output(stdout, stderr):
                    return stderr
            else:
                @staticmethod
                def _grab_output(stdout, stderr):
                    return stdout

            if kwargs["use_stdin"]:
                @staticmethod
                def _pass_file_as_stdin_if_needed(file):
                    return file
            else:
                @staticmethod
                def _pass_file_as_stdin_if_needed(file):
                    return None

            @contextmanager
            def generate_config(self, filename, file):
                content = self.handler.generate_config(filename, file)
                if content is None:
                    yield None
                else:
                    pass
                    # TODO
                    # Create temporary file here with contents and return the
                    # path.

            def run(self, filename, file):
                with self.generate_config(filename, file) as config_file:
                    stdout, stderr = self._execute_command(
                        self.handler.create_arguments(filename,
                                                      file,
                                                      config_file),
                        stdin=self._pass_file_as_stdin_if_needed(file))
                    output = self._grab_output(stdout, stderr)
                    self._process_output(output, filename, file)

        return Linter

    return create_linter
