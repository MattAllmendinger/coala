from contextlib import contextmanager
import re
import shutil
from tempfile import NamedTemporaryFile

from coalib.bears.LocalBear import LocalBear
from coalib.misc.Decorators import enforce_signature
from coalib.misc.Shell import run_shell_command
from coalib.results.Diff import Diff
from coalib.results.Result import Result
from coalib.results.RESULT_SEVERITY import RESULT_SEVERITY


class BearSetting:
    @enforce_signature
    def __init__(self, name: str, typ: type, default=None):
        if default is not None and type(default) is not typ:
            raise ValueError("Default is not of given type.")

        self._name = name
        self._type = typ
        self._default = default

    @property
    def name(self):
        return self._name

    @property
    def type(self):
        return self._type

    @property
    def default(self):
        return self._default


# TODO Move to another file? --> uhm yes?
class LinterHandler:
    # TODO Damn fuck what about required section settings....
    # TODO --> Maybe it's possible to insert metadata after instantation?
    # TODO --> should be possible, bear has such a function...
    # TODO ------> But how should setting-names, types and default values look?
    # TODO -----------> Settings need to be provided inside create_arguments
    # TODO -----------> maybe as dict or directly the settings object!!!
    # TODO ----------------> Or just grab the signature from `create_arguments`
    # TODO Doing the handler stuff below static? see line above^^
    @staticmethod
    def create_arguments(filename, file, config_file):
        """
        Creates the arguments for the linter.

        :param filename:    The name of the file the linter-tool shall process.
        :param file:        The contents of the file.
        :param config_file: The path of the config-file if used. ``None`` if
                            unused.
        :return:            A sequence of arguments to feed the linter-tool
                            with.
        """
        raise NotImplementedError

    @staticmethod
    def settings():
        """
        A sequence of ``BearSetting``s containing the settings needed for the
        bear and their possible defaults.

        :return: The required settings.
        """
        return {}

    @staticmethod
    def generate_config(filename, file):
        """
        Generates the content of a config-file the linter-tool might need.

        The contents generated from this function are written to a temporary
        file and the path is provided inside ``create_arguments()``.

        By default no configuration is generated.

        :param filename: The name of the file currently processed.
        :param file:     The contents of the file currently processed.
        :return:         The config-file-contents as a string or ``None``.
        """
        return None

    @classmethod
    def check_prerequisites(cls):
        """
        Checks whether the linter-tool the bear uses is operational.

        :return: True if available, otherwise a string containing more info.
        """
        if shutil.which(cls.executable) is None:
            return repr(cls.executable) + " is not installed."
        else:
            return True


# TODO Replace `x` with ``x`` because of rst

# TODO docs

@enforce_signature
def Linter(executable: str,
           provides_correction: bool=False,
           use_stdin: bool=False,
           use_stderr: bool=False,
           **kwargs):
    """
    Decorator that creates a ``LocalBear`` that is able to process results from
    an external linter tool.

    The interface to the tool is the ``LinterHandler`` class that defines
    functions you can hook up to. See ``LinterHandler`` for more details on
    usage.

    >>> @Linter("xlint")
    ... class XLintBear:
    ...     def create_arguments(self, filename, file, config_file):
    ...         return ("--lint", filename)

    :param executable:          The linter tool.
    :param provides_correction: Whether the underlying executable provides as
                                output the entirely corrected file instead of
                                issue messages.
    :param use_stdin:           Whether the input file is send via stdin
                                instead of passing it over the
                                command-line-interface.
    :param use_stderr:          Whether stderr instead of stdout should be
                                grabbed for the executable output.
    :param output_regex:        The regex expression as a string that is used
                                to parse the output generated by the underlying
                                executable. It should use as many of the
                                following named groups (via ``(?P<name>...)``)
                                to provide a good result:

                                - line - The line where the issue starts.
                                - column - The column where the issue starts.
                                - end_line - The line where the issue ends.
                                - end_column - The column where the issue ends.
                                - severity - The severity of the issue.
                                - message - The message of the result.
                                - origin - The origin of the issue.

                                Needs to be provided if ``provides_correction``
                                is ``False``.
    :param severity_map:        A dict used to map a severity string (captured
                                from the ``output_regex`` with the named group
                                ``severity``) to an actual
                                ``coalib.results.RESULT_SEVERITY`` for a
                                result.
                                By default maps the values ``error`` to
                                ``RESULT_SEVERITY.MAJOR``, ``warning`` to
                                ``RESULT_SEVERITY.NORMAL`` and ``info`` to
                                ``RESULT_SEVERITY.INFO``.
                                Only needed if ``provides_correction`` is
                                ``False``.
    :param diff_severity:       The severity to use for all results if
                                ``provides_correction`` is set. By default this
                                value is
                                ``coalib.results.RESULT_SEVERITY.NORMAL``.
    :param diff_message:        The message to use for all results if
                                ``provides_correction`` is set. By default this
                                value is ``"Inconsistency found."``.
    :return:                    A ``LocalBear`` derivation that lints code
                                using an external tool.
    """
    kwargs["executable"] = executable
    kwargs["use_stdin"] = use_stdin
    kwargs["use_stderr"] = use_stderr
    kwargs["provides_correction"] = provides_correction

    allowed_kwargs = {"executable",
                      "use_stdin",
                      "use_stderr",
                      "provides_correction"}

    if kwargs["provides_correction"]:
        if "diff_severity" not in kwargs:
            kwargs["diff_severity"] = RESULT_SEVERITY.NORMAL
        if "diff_message" not in kwargs:
            kwargs["diff_message"] = "Inconsistency found."

        allowed_kwargs |= {"diff_severity", "diff_message"}
    else:
        if "output_regex" not in kwargs:
            raise ValueError("No `output_regex` specified.")

        kwargs["output_regex"] = re.compile(kwargs["output_regex"])

        # Don't setup severity_map if one is provided by user or if it's not
        # used inside the output_regex.
        if (
                "severity" in kwargs["output_regex"].groupindex and
                "severity_map" not in kwargs):
            kwargs["severity_map"] = {"error": RESULT_SEVERITY.MAJOR,
                                      "warning": RESULT_SEVERITY.NORMAL,
                                      "info": RESULT_SEVERITY.INFO}

        allowed_kwargs |= {"output_regex", "severity_map"}

    # Check for illegal superfluous kwargs.
    superfluous_kwargs = kwargs.keys() - allowed_kwargs
    if superfluous_kwargs:
        raise ValueError("Superfluous keyword argument " +
                         repr(superfluous_kwargs.pop()) + " provided.")

    def create_linter(cls):
        if not isinstance(cls, LinterHandler):
            raise ValueError("Provided class must be derived from "
                             "`LinterHandler`.")

        # Mixing the user-defined interface and the default LinterHandler.
        class UserLinterHandler(cls, LinterHandler):
            pass

        class Linter(LocalBear):
            @property
            def handler(self):
                return UserLinterHandler

            @property
            def executable(self):
                return kwargs["executable"]

            check_prerequisites = handler.check_prerequisites

            def _execute_command(self, args, stdin=None):
                return run_shell_command(self.executable,) + tuple(args),
                                         stdin=stdin)

            def match_to_result(self, match, filename):
                """
                Converts a regex match's groups into a result.

                :param match:    The match got from regex parsing.
                :param filename: The name of the file from which this match is got.
                """
                groups = self._get_groupdict(match)

                # Pre process the groups
                for variable in ("line", "column", "end_line", "end_column"):
                    if variable in groups and groups[variable]:
                        groups[variable] = int(groups[variable])

                if "origin" in groups:
                    groups['origin'] = "{} ({})".format(str(type(self).__name__),
                                                        str(groups["origin"]))

                return Result.from_values(
                    origin=groups.get("origin", self),
                    message=groups.get("message", ""),
                    file=filename,
                    severity=int(groups.get("severity", RESULT_SEVERITY.NORMAL)),
                    line=groups.get("line", None),
                    column=groups.get("column", None),
                    end_line=groups.get("end_line", None),
                    end_column=groups.get("end_column", None))

            if kwargs["provides_correction"]:
                def _process_output(self, output, filename, file):
                    for diff in Diff.from_string_arrays(
                            file,
                            output.splitlines(keepends=True)).split_diff():
                        yield Result(self,
                                     self.diff_message,
                                     affected_code=(diff.range(filename),),
                                     diffs={filename: diff},
                                     severity=self.diff_severity)
            else:
                def _process_output(self, output, filename, file):
                    for match in self.output_regex.finditer(output):
                        # TODO Inline match_to_result? I'm really not sure,
                        # TODO this function makes sense...
                        yield self.match_to_result(match, filename)

            if kwargs["use_stderr"]:
                @staticmethod
                def _grab_output(stdout, stderr):
                    return stderr
            else:
                @staticmethod
                def _grab_output(stdout, stderr):
                    return stdout

            if kwargs["use_stdin"]:
                @staticmethod
                def _pass_file_as_stdin_if_needed(file):
                    return file
            else:
                @staticmethod
                def _pass_file_as_stdin_if_needed(file):
                    return None

            @contextmanager
            def generate_config(self, filename, file):
                content = self.handler.generate_config(filename, file)
                if content is None:
                    yield None
                else:
                    with NamedTemporaryFile(mode="w") as config_file:
                        config_file.write(content)
                        config_file.close()
                        yield config_file.name

            def run(self, filename, file):
                with self.generate_config(filename, file) as config_file:
                    stdout, stderr = self._execute_command(
                        self.handler.create_arguments(filename,
                                                      file,
                                                      config_file),
                        stdin=self._pass_file_as_stdin_if_needed(file))
                    output = self._grab_output(stdout, stderr)
                    self._process_output(output, filename, file)

        return Linter

    return create_linter
